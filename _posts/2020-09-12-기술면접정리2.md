---
title : '기술면접 정리2'
date : 2020-09-12
---



2차 면접에선 뭘 물어봤을까



## 경력과 업무 질문

1. 간략한 자기 소개와 지원 동기
- 왜 경력을 포기하면서 도메인을 변경하려고 하는지
- 기존 업무에서 성과 / 기술적 강점
- 기존 업무와 지원업무의 연관성
- 업무에서 주도적으로 진행했던 내용



## 기존 업무(임베디드프로그래밍) 질문

1. 프로세스와 스레드의 차이점

2. 멀티프로세싱과 멀티스레딩의 차이점

3. 언제 멀티프로세싱을 사용해야 하는가?

   1. OS 나 CPU에서 멀티스레드를 지원하지 않을 때
   2. 멀티프로세스의 잇점을 사용할 때
      1. 프로세스마다 독립된 메모리를 갖기 때문에 비정상시에 종료되어도 유지할 수 있는 부분이 크다
      2. 코드가 직관적이며 동기화 이슈에 대한 우려가 없다. (공유메모리를 사용하지 않는 경우)
      3. 스레드가 사용자에게 응답성을 제공하는 반면, 프로세스는 주어진 시간에 하나의 일을 최대 효율로 해낼 때 사용한다.

4. 다형성이 무엇인가

5. C++ 의 다중상속을 Java에서 지원하지 않는 이유는 무엇인가?

   다중상속은 부모 인스턴스의 실체가 둘 이상일 수 있기 때문에 모호한 문제들이 발생한다. Java에서는 구현체는 없는 인터페이스의 다중 구현으로 문제를 해결한다.

   1. 다중상속한 부모 클래스 A,B에 동일한 이름의 변수나 함수가 존재하는 경우, 각각이 동시에 존재하며 자식클래스에서는 재정의가 필요하며, 각각의 부모 멤버를 ClassA::sameName() 처럼 호출할 수 있다.
   2. 할아버지 클래스가 동일한 경우 역시 어떤 부모를 통해할 때 모호함의 문제가 발생한다. Liger -> Tiger & Lion -> Animal 경우, ((Tiger)liger).giveABirth() 처럼 호출이야 가능하지만 역시 이상하다.
   3. Java의 GC을 사용했을 때 느낀점과 기존 C++ 에서 직접 메모리를 관리할 때 가지는 장점
      unmanaged 언어의 경우 메모리의 할당과 해제가 명시적이고 프로그래머의 이해가 직관적이다. 반면 생산성이 떨어지는 문제점이 있다.
      반대로 managed 언어는 생산성은 올라가지만 메모리 관리가 암시적으로 발생한다. 따라서 프로그래머가 managed 언어가 메모리를 관리하는 정책을 잘 이해해야 더 효율적인 프로그램을 작성할 수 있다. 예를 들어서, Java의 경우 JVM에서 각 인스턴스에 연결된 참조자 갯수를 기록하다가 0이 되면 메모리가 해제된다. 함수를 호출하면 함수 scope의 인스턴스들이 메모리를 할당 받고, 이 인스턴스를 파라미터로 다른 함수를 호출하면 참조자의 수가 증가한다. 반대로 함수를 종료하여 스택 메모리에서 pop 되면 참조수가 줄어드는 식이다. 따라서, 인스턴스의 참조자가 선언된 scope가 끝나지 않으면 해당 인스턴스의 사용이 종료되었더라도 메모리를 점유하고 있는 문제가 발생한다. 명시적으로 인스턴스의 사용범위로 scope 나 함수를 작성하여 이 문제를 해결할 수 있다.



## 신규 업무(웹서비스) 질문

1. (1차면접 재질문) REST에서 PATCH 요청의 역할

   POST 가 생성, PUT 이 업데이트를 목적을 갖는 반면, PATCH 는 부분 업데이트가 가능하다.
   RFC5789 에서 HTTP 프로토콜의 PATCH, RFC6902에서 특별히 JSON PATCH 를 다루고 있는데,
   JSON PATCH 를 예시를 들면 op, path, value 등의 attribute 를 가진 json 을 전달하여 move, replace, add, remove 등의 operation 을 수행할 수 있다.

2. (1차면접 재질문) POST 요청이 성공적으로 수행되었을 때 꼭 200 응답을 줘야 할까?
   - 1xx : 정보성
   - 2xx : 성공 - 200 성공
   - 3xx : 리다이렉트 - 301 이동 (www), 304 Not modified (캐시)
   - 4xx : 클라이언트 오류 - 404 (not found)
   - 5xx : 서버 오류 - 500(internal server error), 503 (service unavailable)

3. TLS 동작원리

4. HTTP 요청의 구성요소와 역할
   - start line (method + target + protocol)
   - headers (request/general/entity)
   - body (single-resource/multiple-resources)

5. HTTP 1.0/1.1/2/3 프로토콜의 특정 개선점
   - HTTP/0.9
     원라인프로토콜 ; GET 요청과 응답만 존재
   - HTTP/1.0
     버전, 헤더, Content-Type 지원 추가

   - HTTP/1.1
     Keep-Alive, Pipelining, 캐시, 인코딩 등 확장 / https 지원 등의 내용이 지속적으로 추가 됨

   - HTTP/2.0
     다중화, 헤더압축, 우선순위화, 프로토콜 협상
     
   - HTTP/3

6. TLS 암호화 방식 및 동작 구조
   

## 기타

- 기존 업무 환경에서 아쉬웠던 것과 새로운 업무 환경에서 기대하는 것
- 추가 질문?

* 도메인 변경하는 경우 면접관들도 왜 뽑아야 하는지 어디서부터 시작해야 할 지 막막해 함
* 1차면접에서 만족스럽지 않은 대답 / 미응답에 대해서 추가로 공부했는지 확인함
* 발전 가능성이 있는지, 웹기술에 관심을 두고 찾아보거나 개인적으로 공부하는지 확인함